# 算法与数据结构

## 算法

### 排序

[https://blog.csdn.net/lutianfeiml/article/details/51958962](https://blog.csdn.net/lutianfeiml/article/details/51958962)

[https://www.cnblogs.com/RainyBear/p/5258483.html](https://www.cnblogs.com/RainyBear/p/5258483.html)

| 排序方法     | 平均情况        | 最好情况 | 最坏情况 | 辅助空间     | 稳定性 |
| ------------ | --------------- | -------- | -------- | ------------ | ------ |
| 冒泡排序     | O(n^2)          | O(n)     | O(n^2)   | O(1)         | 稳定   |
| 简单选择排序 | O(n^2)          | O(n^2)   | O(n^2)   | O(1)         | 稳定   |
| 直接插入排序 | O(n^2)          | O(n)     | O(n^2)   | O(1)         | 稳定   |
| 希尔排序     | O(nlogn)~O(n^2) | O(n^1.3) | O(n^2)   | O(1)         | 不稳定 |
| 堆排序       | O(nlogn)        | O(nlogn) | O(nlogn) | O(1)         | 不稳定 |
| 归并排序     | O(nlogn)        | O(nlogn) | O(nlogn) | O(n)         | 稳定   |
| 快速排序     | O(nlogn)        | O(nlogn) | O(n^2)   | O(logn)~O(n) | 不稳定 |

#### 冒泡排序

[成绩排序](https://www.nowcoder.com/practice/0383714a1bb749499050d2e0610418b1?tpId=40&tqId=21333&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

这个题需要稳定的排序算法，所以手撸冒泡

```c++
#include<bits/stdc++.h>
using namespace std;

struct stu{
    string name;
    int grade;
};

bool cmp2(stu s1, stu s2){
    return s1.grade>s2.grade;
}

bool cmp1(stu s1, stu s2){
    return s1.grade<s2.grade;
}

int main(){
    int n, how;
    stu s[10000];
    while(cin>>n>>how){
        for(int i=0;i<n;i++)
            cin>>s[i].name>>s[i].grade;
        for(int i=0;i<n;i++){
            for(int j=0;j<n-i-1;j++){
                if(how==0 && cmp1(s[j], s[j+1]))
                    swap(s[j], s[j+1]);
                else if(how==1 && cmp2(s[j], s[j+1]))
                    swap(s[j], s[j+1]);
            }
        }
        for(int i=0;i<n;i++)
            cout<<s[i].name<<' '<<s[i].grade<<endl;
    }
}

```

#### 归并排序

```c++
int n, a[100];

void merge(int s, int mid, int e){
    int l[100], r[100], len1=mid-s+1, len2=e-mid;
    for(int i=0;i<len1;i++) l[i]=a[s+i];
    for(int i=0;i<len2;i++) r[i]=a[mid+i+1];
    int i=0,j=0,k=s;
    while(k<e && i<len1 && j<len2){
        if(l[i]<=r[j]) a[k]=l[i++];
        else a[k]=r[j++];
        k++;
    }
    while(i<len1) a[k++]=l[i++];
    while(j<len2) a[k++]=r[j++];
}

void merge_sort(int s, int e){
    if(s<e){
        int mid=(s+e)/2;
        merge_sort(s, mid);
        merge_sort(mid+1, e);
        merge(s, mid, e);
    }
}

int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    merge_sort(0, n-1);
    for(int i=0;i<n;i++)
        cout<<a[i]<<' ';
    cout<<endl;
}
```

#### 快速排序

```c++
int n, a[100];

int partition(int s, int e){
    int p=a[s], l=s, r=e;
    while(l<r){
        while(l<r && a[r]>=p) r--;
        a[l]=a[r];
        while(l<r && a[l]<=p) l++;
        a[r]=a[l];
    }
    a[l]=p;
    return l;
}

void quick_sort(int s, int e){
    if(s<e){
        int p = partition(s, e);
        quick_sort(s, p-1);
        quick_sort(p+1, e);
    }
}

int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    quick_sort(0, n-1);
    for(int i=0;i<n;i++)
        cout<<a[i]<<' ';
    cout<<endl;
}
```



### 搜索 

#### BFS

[Meteor Shower](http://poj.org/problem?id=3669)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;

const int maxn = 405;
const int inf=9999999;
int m[maxn][maxn];
const int dir[][2]={1,0, -1,0, 0,1, 0,-1, 0,0};
struct node{int x,y,t;};

int bfs(){
    if(m[0][0]==0) return -1;
    else if(m[0][0]==-1) return 0;
    node a;
    a.x=a.y=a.t=0;
    queue<node>q;
    q.push(a);
    while( !q.empty() ){
        node b=q.front();
        q.pop();
        for(int i=0;i<4;i++ ){
            a.x=b.x+dir[i][0];
            a.y=b.y+dir[i][1];
            a.t=b.t+1;
            if(a.x<0||a.y<0||a.x>=maxn||a.y>=maxn) continue;
            if(m[a.x][a.y]==-1) return a.t;
            if(a.t>=m[a.x][a.y]) continue;
            m[a.x][a.y]=a.t;
            q.push(a);
        }
    }
    return -1;
}

int main(){
    int n;
    while(scanf("%d",&n)!=EOF){
        int x,y,t;
        memset(m,-1,sizeof(m));
        while(n--){
            scanf("%d%d%d",&x,&y,&t);
            for(int i=0;i<5;i++){
                int xx=x+dir[i][0];
                int yy=y+dir[i][1];
                if(xx<0||yy<0||xx>=maxn||yy>=maxn) continue;
                if(m[xx][yy]==-1) m[xx][yy]=t;
                else m[xx][yy]=min(m[xx][yy], t);
            }
        }
        printf("%d\n", bfs());
    }
    return 0;
}
```

[玛雅人的密码](https://www.nowcoder.com/practice/761fc1e2f03742c2aa929c19ba96dbb0?tpId=40&tqId=21343&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

struct node{
    string x;
    int step;
};
queue<node> q;
set<string> s;
string a;
int n;

int main(){
    while(cin>>n){
        cin>>a;
        s.insert(a);
        node b;
        b.x=a; b.step=0;
        q.push(b);
        int cnt=0;
        bool flag=0;
        while(!q.empty()){
            b=q.front();
            q.pop();
            int f=b.x.find("2012");
            if(f>=0 && f<n){
                cout<<b.step<<endl;
                flag=1;
                break;
            }
            for(int i=0;i<n-1;i++){
                node c;
                c.x=b.x; c.step=b.step+1;
                swap(c.x[i], c.x[i+1]);
                if(s.find(c.x)==s.end()){
                    s.insert(c.x);
                    q.push(c);
                }
            }
        }
        if(!flag) cout<<"-1"<<endl;
    }
}
```

[I Wanna Go Home](https://www.nowcoder.com/practice/0160bab3ce5d4ae0bb99dc605601e971?tpId=40&tqId=21359&rp=2&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<queue>
using namespace std;

const int maxn=605;
struct node{
    int x, c;
    bool u;
    bool operator < (node b) const{
        return c>b.c;
    }
};
priority_queue<node> q;
int n, m, l[maxn];
bool used[maxn];
struct edge{int t, c;};
vector<edge> g[maxn];

int bfs(){
    while(!q.empty()) q.pop();
    memset(used, 0, sizeof(used));
    node a;
    a.x=1; a.c=0; a.u=false;
    q.push(a);
    
    while(!q.empty()){
        a=q.top(); q.pop();
        int u=a.x, v;
        if(u==2) return a.c;
        used[u]=true;
        for(int i=0;i<g[u].size();i++){
            v=g[u][i].t;
            if(used[v] || (a.u && l[u]!=l[v]))
                continue;
            node b;
            b.x=v; b.c=a.c+g[u][i].c;
            if(l[u]!=l[v]) b.u=true;
            else b.u=a.u;
            q.push(b);
        }
    }
    return -1;
}

int main(){
    while(cin>>n){
        if(n==0) break;
        cin>>m;
        for(int i=1;i<=n;i++) g[i].clear();
        for(int i=0;i<m;i++){
            int f, t, c;
            cin>>f>>t>>c;
            edge e; e.t=t; e.c=c;
            g[f].push_back(e);
            e.t=f;
            g[t].push_back(e);
        }
        for(int i=1;i<=n;i++) cin>>l[i];
        cout<<bfs()<<endl;
    }
}
```



#### DFS

[Red and Black](http://poj.org/problem?id=1979)

```c++
#include<bits/stdc++.h>
using namespace std;

int W, H, sx, sy, ans;
int dir[4][2]={1,0, -1,0, 0,1, 0,-1};
char m[25][25];

bool check(int x, int y){
    if(x>=0 && x<H && y>=0 && y<W)
        return true;
    return false;
}

void dfs(int x, int y){
    ans++;
    m[x][y]='@';
    for(int i=0;i<4;i++){
        int xx=x+dir[i][0], yy=y+dir[i][1];
        if(check(xx, yy) && m[xx][yy]=='.')
            dfs(xx, yy);
    }
}

int main(){
    while(cin>>W>>H){
        if(W==0 || H==0) break;
        for(int i=0;i<H;i++){
            for(int j=0;j<W;j++){
                cin>>m[i][j];
                if(m[i][j]=='@'){
                    sx=i; sy=j;
                }
            }
        }

        ans=0;
        dfs(sx, sy);
        cout<<ans<<endl;
    }
}
```

[Curling 2.0](http://poj.org/problem?id=3009)

```c++
#include<bits/stdc++.h>
using namespace std;

int W, H, sx, sy, ans;
int dir[4][2]={1,0, -1,0, 0,1, 0,-1};
char m[25][25];

bool check(int x, int y){
    if(x>=0 && x<H && y>=0 && y<W)
        return true;
    return false;
}

void dfs(int x, int y, int step){
    if(step>10) return;
    for(int i=0;i<4;i++){
        int xx=x+dir[i][0], yy=y+dir[i][1];
        if(m[xx][yy]=='1') continue;
        while(1){
            if(!check(xx, yy)) break;
            if(m[xx][yy]=='3') {
                ans=min(ans, step+1);
                break;
            }
            if(m[xx][yy]=='1'){
                m[xx][yy]='0';
               dfs(xx-dir[i][0], yy-dir[i][1], step+1);
                m[xx][yy]='1';
                break;
            }
            xx+=dir[i][0];
            yy+=dir[i][1];
        }
    }
}

int main(){
    while(cin>>W>>H){
        if(W==0 || H==0) break;
        for(int i=0;i<H;i++){
            for(int j=0;j<W;j++){
                cin>>m[i][j];
                if(m[i][j]=='2'){sx=i; sy=j;}
            }
        }
        ans=11;
        dfs(sx, sy, 0);
        if(ans<=10) cout<<ans<<endl;
        else cout<<"-1"<<endl;
    }
}
```

[Hopscotch](http://poj.org/problem?id=3050)

```c++
#include<bits/stdc++.h>
using namespace std;

int grid[6][6],t;
const int dir[4][2]={1,0,-1,0,0,1,0,-1};
set<int> x;

void dfs(int a,int b,int depth)
{
    if(depth==5){
        x.insert(t);
        return;
    }
    for(int i=0;i<4;i++){
        int x,y;
        x=a+dir[i][0];
        y=b+dir[i][1];
        if(x<0 || x>=5 || y<0 || y>=5) continue;
        t=t*10+grid[x][y];
        dfs(x,y,depth+1);
        t-=grid[x][y];
        t/=10;
    }
}

int main()
{
    for(int i=0;i<5;i++)
        for(int j=0;j<5;j++)
            scanf("%d",&grid[i][j]);
    for(int i=0;i<5;i++){
        for(int j=0;j<5;j++){
            t=grid[i][j];
            dfs(i,j,0);
        }
    }
    printf("%d",x.size());
}
```



[神奇的口袋](https://www.nowcoder.com/practice/9aaea0b82623466a8b29a9f1a00b5d35?tpId=40&tqId=21390&tPage=3&rp=3&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

int a[30], n, m=0;

void dfs(int x, int step){
    if(x>40) return;
    if(x==40) m++;
    for(int i=step;i<n;i++)
        dfs(x+a[i], i+1);
}

int main(){
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>a[i];
    dfs(0, 0);
    cout<<m<<endl;
}

```

[八皇后](https://www.nowcoder.com/practice/fbf428ecb0574236a2a0295e1fa854cb?tpId=40&tqId=21417&tPage=5&rp=5&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

int q[10];
vector<int> ans;

void dfs(int x){
    if(x==8){
        int seq=0;
        for(int i=1;i<=8;i++)
            seq=seq*10+q[i];
        ans.push_back(seq);
    }
    x++;
    for(int i=1;i<=8;i++){
        q[x]=i;
        bool valid=true;
        for(int j=1;j<x;j++){
            if(q[x]==q[j] || abs(x-j)==abs(q[x]-q[j]))
                valid=false;
        }
        if(valid) dfs(x);
    }
}

int main(){
    int b;
    dfs(0);
    while(cin>>b)
        cout<<ans[b-1]<<endl;
}

```

#### 二分搜索



#### 暴力枚举

[Smallest Difference](http://poj.org/problem?id=2718)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

int main(){
    int T,a[15],n;
    char b[20];
    cin>>T;
    getchar();
    while(T--){
        gets(b);
        n=0;
        for(int i=0;i<strlen(b);i++)
            if(b[i]>='0' && b[i]<='9')
                a[n++]=b[i]-'0';

        int MIN=987654321;
        do{
            // 除了数字0外，其他数不能以0开头
            if((a[0]==0 || a[n/2]==0) && n>2)
                continue;
            int x=0, y=0;
            // 两个数位数相近，差才最小
            for(int i=0;i<n/2;i++)
                x=x*10+a[i];
            for(int i=n/2;i<n;i++)
                y=y*10+a[i];
            MIN=min(MIN, abs(x-y));
        }while(next_permutation(a, a+n));
        cout<<MIN<<endl;
    }
}
```

[Backward Digit Sums](http://poj.org/problem?id=3187)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

int c(int n, int k){
	int res = 1;
	for(int i=0;i<k;i++)
        res=res*(n-i)/(i+1);
	return res;
}

int main(){
    int n, m;
    cin>>n>>m;
    int sum=0, a[15];
    for(int i=0;i<10;i++)
        a[i]=i+1;
    do{
        sum=0;
        for(int i=0;i<n;i++)
            // 每个数的系数是组合数（杨辉三角）
            sum+=a[i]*c(n-1,i);
        if(sum==m) break;
    }while(next_permutation(a, a+n));
    for(int i=0;i<n;i++)
        cout<<a[i]<<' ';
    cout<<endl;
}
```

### DP

[放苹果](https://www.nowcoder.com/practice/4f0c1e21010e4d849bde5297148e81d9?tpId=40&tqId=21372&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

- 设$dp[i][j]$为把$i$个苹果放进$j$个盘子的放法数目，则先对盘子数$j$作讨论：
  - 当$j>i$：必定有j-i个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响，此时$dp[i][j] = dp[i][i]$
  - 当$j\le i$：不同的放法可以分成两类：
    - 有至少一个盘子空着，即相当于$dp[i][j] = dp[i][j-1]$;
    - 所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即$dp[i][j]=dp[i-j][j]$
    - 总的放苹果的放法数目等于两者的和，即$dp[i][j]=dp[i][j-1]+dp[i-j][j]$

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

int m, n, dp[15][15];

int main(){
    while(cin>>m>>n){
        memset(dp, 0, sizeof(dp));
        for(int i=0;i<=m;i++) dp[i][1]=1;
        for(int i=0;i<=n;i++) dp[0][i]=1;
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(i<j) dp[i][j]=dp[i][i];
                else dp[i][j]=dp[i][j-1]+dp[i-j][j];
            }
        }
        cout<<dp[m][n]<<endl;
    }
}
```

[整数拆分](https://www.nowcoder.com/practice/376537f4609a49d296901db5139639ec?tpId=40&tqId=21339&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

- $dp[2m+1]=dp[2m]$
- $dp[2m]=dp[m]+dp[2m-1]$

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn=1000000+5;
int n, m[maxn];

int main(){
    while(cin>>n){
        m[0]=1;
        for(int i=1;i<=n;i++){
            if(i%2==1) m[i]=m[i-1]%1000000000;
            else m[i]=(m[i-1]+m[i/2])%1000000000;
        }
        cout<<m[n]<<endl;
    }
}
```
[Apple Catching](http://poj.org/problem?id=2385)

- $dp[i][j]$表示在$j$分钟内移动$i$次最多能接到的苹果数
- $c=\begin{cases} 1 & \text{第$j$分钟能接到苹果$a[j]$} \\ 0 & \text{第$j$分钟不能接到苹果$a[j]$} \end{cases}$
- 根据$i$分两种情况讨论：
  - 第$j$分钟已经移动了$i$次，此时$dp[i][j]=dp[i][j-1]+c$
  - 第$j$分钟只移动了$i-1$次，还需要移动一次，此时$dp[i][j]=dp[i-1][j-1]+c$
- 初始化细节：$j\le i$ 时每分钟都移动一次

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int maxn=1005;
int n, w, a[maxn], dp[35][maxn];

int main(){
    cin>>n>>w;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[i]--;
    }
    memset(dp, 0, sizeof(dp));
    for(int i=1;i<=n;i++)
        dp[0][i]=(a[i]==0) ? dp[0][i-1]+1 : dp[0][i-1];
    for(int i=1;i<=w;i++){
        int s=0;
        for(int j=1;j<=n;j++){
            int c;
            if(j<=i){
                s++; s%=2;
                c=(a[j]==s);
                dp[i][j]=dp[i][j-1]+c;
            }else{
                s=i%2;
                c=(a[j]==s);
                dp[i][j]=max(dp[i-1][j-1]+c, dp[i][j-1]+c);
            }
        }
    }
    cout<<dp[w][n]<<endl;
}
```

[Milking Time](http://poj.org/problem?id=3616)

- 定义$dp[i]$表示第$i$个时间段挤奶能够得到的最大值，拆开来说，就是前面$ i – 1$个时间段任取$0$到$i – 1$个时间段挤奶，然后加上这个时间段$i$的产奶量之和。$dp[i]$满足如下递推关系：
- 第$i$个时间段挤奶的最大值 = 前$ i – 1 $个时间段挤奶最大值中的最大值 + 第$i$次产奶量。

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int maxn=1005;
int n, m, r, dp[maxn];
struct node{int s, e, v;};
node a[maxn];

bool cmp(node x, node y){
    if(x.s==y.s)
        return x.e<y.e;
    return x.s<y.s;
}

int main(){
    cin>>m>>n>>r;
    for(int i=0;i<n;i++){
        cin>>a[i].s>>a[i].e>>a[i].v;
        a[i].e+=r;
    }
    sort(a, a+n, cmp);

    int ans=0;
    for(int i=0;i<n;i++){
        dp[i]=a[i].v;
        for(int j=0;j<i;j++){
            if(a[j].e<=a[i].s)
                dp[i]=max(dp[i], dp[j]+a[i].v);
        }
        ans=max(ans, dp[i]);
    }
    cout<<ans<<endl;
}
```



#### 0/1背包

```c++
const int maxn=350+5, INF=(1<<31);
int n, c, w[maxn], v[maxn];
int dp[maxn];

int main(){
    cin>>n>>c;
    for(int i=0;i<n;i++)
            cin>>w[i]>>v[i];
    
    // 初始化
	// 不需要恰好装满
    for(int i=0;i<=c;i++)
        dp[i]=0;
    // 恰好装满
    dp[0]=0;
    for(int i=1;i<=c;i++)
        dp[i]=INF;
    
    for(int i=0;i<n;i++)
        for(int j=c;j>=w[i];j--)
            dp[j]=max(dp[j], dp[j-w[i]]+v[i]);
    cout<<dp[c]<<endl;
}
```

[采药](https://www.nowcoder.com/practice/d7c03b114f0541dd8e32ce9987326c16?tpId=40&tqId=21406&rp=4&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<queue>
using namespace std;

const int maxn=100+5;
int t, m, c[maxn], w[maxn], dp[1005];

int main(){
    cin>>t>>m;
    for(int i=0;i<m;i++)
        cin>>c[i]>>w[i];
    memset(dp, 0, sizeof(dp));
    for(int i=0;i<m;i++)
        for(int j=t;j>=c[i];j--)
            dp[j]=max(dp[j], dp[j-c[i]]+w[i]);
    cout<<dp[t]<<endl;
}
```

[最小邮票数](https://www.nowcoder.com/practice/83800ae3292b4256b7349ded5f178dd1?tpId=40&tqId=21345&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<queue>
using namespace std;

int n, m, a[25], dp[105], INF=100000;

int main(){
    while(cin>>m){
        cin>>n;
        for(int i=0;i<n;i++) cin>>a[i];
        fill(dp, dp+m+1, INF);
        dp[0]=0;
        for(int i=0;i<n;i++){
            for(int j=m;j>=a[i];j--)
                dp[j]=min(dp[j], dp[j-a[i]]+1);
        }
        if(dp[m]!=INF)
            cout<<dp[m]<<endl;
        else cout<<0<<endl;
    }
}
```



#### 完全背包

```c++
// 顺序更新使得每个物品可以放多次
for(int i=0;i<n;i++)
    for(int j=w[i];j<=c;j++)
        dp[j]=max(dp[j], dp[j-w[i]]+v[i]);
cout<<dp[c]<<endl;
```



#### 最长公共子序列

- dp\[i][j]: $s_1, \ldots, s_i$和$t_1, \ldots, t_j$对应的最长公共子序列（LCS）长度
- $dp[i+1][j+1]= \begin{cases} max(dp[i][j]+1, dp[i][j+1], dp[i+1][j])=dp[i][j]+1 & \text{if } s_{i+1}=t_{j+1}, \\ max(dp[i][j+1], dp[i+1][j]) & \text{otherwise.} \end{cases}$

```c++
int n, m;
string s, t;
int dp[maxn+1][maxm+1];

int main(){
    cin>>s>>t;
    n=s.size(); m=t.size();
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(s[i]==t[j])
                dp[i+1][j+1]=dp[i][j]+1;
            else
                dp[i+1][j+1]=max(dp[i][j+1], dp[i+1][j]);
        }
    }
    cout<<dp[n][m]<<endl;
}
```

[Advanced Fruits](http://acm.hdu.edu.cn/showproblem.php?pid=1503)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<string>
using namespace std;

const int maxn=105;
string a, b;
int dp[maxn][maxn], vis[maxn][maxn];

void print(int x, int y){
    if(x==0 && y==0) return;
    else if(x==0){
        print(x, y-1);
        cout<<b[y-1];
    }else if(y==0){
        print(x-1, y);
        cout<<a[x-1];
    }else if(vis[x][y]==1){
        print(x-1, y-1);
        cout<<a[x-1];
    }else if(vis[x][y]==2){
        print(x, y-1);
        cout<<b[y-1];
    }else if(vis[x][y]==3){
        print(x-1, y);
        cout<<a[x-1];
    }
}

int main(){
    while(cin>>a>>b){
        memset(dp, 0, sizeof(dp));
        memset(vis, 0, sizeof(vis));
        int n=a.size(), m=b.size();
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(a[i]==b[j]){
                    dp[i+1][j+1]=dp[i][j]+1;
                    vis[i+1][j+1]=1;
                }
                else if(dp[i+1][j]>=dp[i][j+1]){
                    dp[i+1][j+1]=dp[i+1][j];
                    vis[i+1][j+1]=2;
                }
                else{
                    dp[i+1][j+1]=dp[i][j+1];
                    vis[i+1][j+1]=3;
                }
            }
        }
        print(n, m);
        cout<<endl;
    }
}
```



#### 最长上升子序列

- dp[i]: 以a[i]为末尾的最长上升子序列（LIS）的长度
- $dp[i]=max\{1, dp[j]+1 | j<i \and a[j]<a[i]\}$

```c++
int n, a[maxn], dp[maxn];

int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    
    int res=0;
    for(int i=0;i<n;i++){
        dp[i]=1;
        for(int j=0;j<i;j++)
            if(a[j]<a[i])
                dp[i]=max(dp[i], dp[j]+1);
        res=max(res, dp[i]);
    }
    cout<<res<<endl;
}
```

[拦截导弹](https://www.nowcoder.com/practice/dad3aa23d74b4aaea0749042bba2358a?tpId=40&tqId=21408&rp=4&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<queue>
using namespace std;

const int maxn=25+5;
int k, m[maxn], dp[maxn];

int main(){
    cin>>k;
    for(int i=0;i<k;i++) cin>>m[i];
    int res=0;
    for(int i=0;i<k;i++){
        dp[i]=1;
        for(int j=0;j<i;j++){
            if(m[j]>=m[i])
                dp[i]=max(dp[i], dp[j]+1);
        }
        res=max(res, dp[i]);
    }
    cout<<res<<endl;
}
```

[最大上升子序列和](https://www.nowcoder.com/practice/dcb97b18715141599b64dbdb8cdea3bd?tpId=40&tqId=21409&rp=4&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<queue>
using namespace std;

const int maxn=1000+5;
int k, m[maxn], dp[maxn];

int main(){
    cin>>k;
    for(int i=0;i<k;i++) cin>>m[i];
    int res=0;
    for(int i=0;i<k;i++){
        dp[i]=m[i];
        for(int j=0;j<i;j++){
            if(m[j]<m[i])
                dp[i]=max(dp[i], dp[j]+m[i]);
        }
        res=max(res, dp[i]);
    }
    cout<<res<<endl;
}
```

[最大序列和](https://www.nowcoder.com/practice/df219d60a7af4171a981ef56bd597f7b?tpId=40&tqId=21353&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

- dp[i] 表示以 a[i] 作为末尾的连续序列的最大和 
- 对于dp[i]，有两种情况
  -  这个最大和的连续序列只有一个元素，即以 A[i] 开始，以 A[i] 结尾，则dp[i]=a[i]
  -  这个最大和的连续序列有多个元素，即从前面某处 A[p] 开始 (p<i)，一直到 A[i] 结尾，则dp[i]=dp[i-1]+a[i]

```c++
#include<iostream>
#include<algorithm>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        long long a, sum=0, ans=(1<<63);
        for(int i=0;i<n;i++){
            scanf("%lld", &a);
            sum=max(sum+a, a);
            ans=max(ans, sum);
        }
        cout<<ans<<endl;
    }
}
```



### 图论

用$V$表示节点集和，$E$表示边集和

#### Bellman-Ford

- $d[i]=min\{d[j]+c[j][i] | e=(j,i)\in E\}$

- 复杂度$O(|V|\times |E|)$

```c++
const int maxv=1000+5, maxe=1000+5, INF=(1<<31)-1;
int V, E, d[maxv];
struct edge{int f, t, c;};
edge es[maxe];
 
void bellman(int s){
    fill(d, d+V, INF);
    d[s]=0;
    while(true){
        bool update=false;
        for(int i=0;i<E;i++){
            edge e=es[i];
            if(d[e.f]!=INF && d[e.t]>d[e.f]+e.c){
                d[e.t]=d[e.f]+e.c;
                update=true;
            }
        }
        if(!update) break;
    }
}

bool negative_loop(){
    memset(d, 0, sizeof(d));
    
    for(int i=0;i<V;i++){
        for(int j=0;j<E;j++){
            edge e=es[j];
            if(d[e.t]>d[e.f]+e.c){
                d[e.t]=d[e.f]+e.c;
                if(i==V-1)	return false;
            }
        }
    }
    return true;
}
```

#### Dijkstra

- 找到最短距离已经确定的顶点，从它出发更新相邻顶点的最短距离
- 复杂度$O(|E|\log{|V|})$（不用堆是$O(V^2)$）
- 不适用于有负边存在的图

```c++
typedef pair<int, int> P;
struct edge{int t, c};
vector<edge> g[maxv];
int d[maxv], prev[maxv];

void dijkstra(int s){
    priority_queue<P, vector<P>, greater<P> > q;
    fill(d, d+V, INF);
    fill(prev, prev+V, -1)
    d[s]=0;
    q.push(P(0, s));
    
    while(!q.empty()){
        P p=q.top(); q.pop();
        int v=p.second;
        if(d[v]<p.first) continue;
        for(int i=0;i<g[v].size();i++){
            edge e=g[v][i];
            if(d[e.t]>d[v]+e.c){
                d[e.t]=d[v]+e.c;
                prev[e.t]=v;
                q.push(P(d[e.t], e.t));
            }
        }
    }
}

// 路径还原
vector<int> get_path(int t){
    vector<int> path;
    for(;t!=-1;t=prev[t]) path.push_back(t);
    reverse(path.begin(), path.end());
    return path;
}
```

#### Floyd

- $d[i][j]=min(d[i][j],d[i][k]+d[k][j])$
- 复杂度$O(|V^3|)$

```c++
int d[maxv][maxv];

void floyd(){
    for(int k=0;k<V;k++)
        for(int i=0;i<V;i++)
            for(int j=0;j<V;j++)
                d[i][j]=min(d[i][j], d[i][k]+d[k][j]);
}
```

#### Prim

- 每次选与生成树距离最近的点加入生成树
- 复杂度$O(|E|\log|V|)$（不用堆是$O(V^2)$）

```c++
typedef pair<int, int> P;
struct edge{int t, c;};
vector<edge> g[maxv];
bool used[maxv];

int prim(){
    int res=0;
    priority_queue<P, vector<P>, greater<P> > q;
    fill(used, used+V, false);
    q.push(P(0, 0));
    
    while(!q.empty()){
        P p=q.top(); q.pop();
        int v=p.second;
        if(used[v]) continue;
        used[v]=true;
        res+=p.first;
        
        for(int i=0;i<g[v].size();i++)
            q.push(P(g[v][i].c, g[v][i].t));
    }
    return res;
}
```

[Freckles](https://www.nowcoder.com/practice/41b14b4cd0e5448fb071743e504063cf?tpId=40&tqId=21371&tPage=2&rp=2&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<queue>
using namespace std;

const int maxn=105;
typedef pair<double, int> P;
priority_queue<P, vector<P>, greater<P> > q;
bool used[105];
int n;
double x[maxn], y[maxn];

double dis(int i, int j){
    return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
}

double prim(){
    memset(used, 0, sizeof(used));
    q.push(P(0, 0));
    double res=0;
    while(!q.empty()){
        P p=q.top(); q.pop();
        int v=p.second;
        if(used[v]) continue;
        used[v]=true;
        res+=p.first;
        
        for(int i=0;i<n;i++)
            if(v!=i)
                q.push(P(dis(v, i), i));
    }
    return res;
}

int main(){
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>x[i]>>y[i];
    printf("%.2f\n", prim());
}
```

[Jungle Roads](https://www.nowcoder.com/practice/75c19b92d6b942f08989b335afbc73c3?tpId=40&tqId=21380&rp=3&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<queue>
using namespace std;

const int maxn=30;
typedef pair<int, int> P;
priority_queue<P, vector<P>, greater<P> > q;
bool used[maxn];
int n;
struct edge{
    int t, c;
    edge(int to, int cost){
        t=to;
        c=cost;
    }
};
vector<edge> g[maxn];

int prim(){
    memset(used, 0, sizeof(used));
    while(!q.empty()) q.pop();
    q.push(P(0, 0));
    int res=0;
    while(!q.empty()){
        P p=q.top(); q.pop();
        int v=p.second;
        if(used[v]) continue;
        used[v]=true;
        res+=p.first;
        
        for(int i=0;i<g[v].size();i++)
            q.push(P(g[v][i].c, g[v][i].t));
    }
    return res;
}

int main(){
    while(cin>>n){
        if(n==0) break;
        for(int i=0;i<n;i++) g[i].clear();
        for(int i=0;i<n-1;i++){
            char c1, c2;
            int k, cost;
            cin>>c1>>k;
            for(int j=0;j<k;j++){
                cin>>c2>>cost;
                g[c1-'A'].push_back(edge(c2-'A', cost));
                g[c2-'A'].push_back(edge(c1-'A', cost));
            }
        }
        cout<<prim()<<endl;
    }
}
```



#### Kruskal

- 每次找权值最小的边，如果这条边所连接的两个节点属于不同的连通分量，则将该边加入生成树
- 用并查集高效地判断是否属于同一连通分量
- 复杂度$O(|E|\log |V|)$

```c++
int par[maxv],r[maxv],V,E;
typedef struct{int u,v,cost;}edge;
edge es[maxne];

// 并查集
void init(int N){
    for(int i=0;i<V;i++){
        par[i]=i;
        r[i]=0;
    }
}

int find(int x){
    if(par[x]==x) return x;
    else return par[x]=find(par[x]);
}

void unite(int x,int y)
{
    x=find(x); y=find(y);
    if(x==y) return;

    if(r[x]<r[y]) par[x]=y;
    else par[y]=x;
    if(r[x]==r[y]) r[x]++;
}

bool same(int x,int y){
    return find(x)==find(y);
}

bool cmp(const edge& e1,const edge& e2){
    return e1.cost<e2.cost;
}

int kruskal(){
    sort(es,es+E,cmp);
    init(V+1);
    int ans=0;
    for(int i=0;i<E;i++){
        edge e=es[i];
        if(!same(e.u , e.v)){
            unite(e.u , e.v);
            ans += e.cost;
        }
    }
    return ans;
}
```



### 贪心

[Cleaning Shifts](http://poj.org/problem?id=2376)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int maxn=25000+5;
int n, t;
struct cow{int s, e;};
cow c[maxn];

bool cmp(cow c1, cow c2){
    if(c1.s==c2.s)
        return c1.e<c2.e;
    return c1.s<c2.s;
}

int main(){
    scanf("%d%d", &n, &t);
    for(int i=0;i<n;i++)
        scanf("%d%d", &c[i].s, &c[i].e);
    sort(c, c+n, cmp);
    int ans=0;
    for(int i=1,j=0;i<=t;){
        int maxi=-1, end=-1;
        // 每次选最长的区间
        for(;j<n;j++){
            if(c[j].s>i) break;
            if(c[j].e>=i && c[j].e-i>maxi){
                maxi=c[j].e-i;
                end=c[j].e;
            }
        }
        if(maxi==-1) {ans=-1; break;}
        i=end+1;
        ans++;
    }
    cout<<ans<<endl;
}
```

[Radar Installation](http://poj.org/problem?id=1328)

思路：[https://blog.csdn.net/ac_hell/article/details/51250550](https://blog.csdn.net/ac_hell/article/details/51250550)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

const int maxn=1000+5;
int n, d, T;
struct node{int x, y;};
node c[maxn];

bool cmp(node c1, node c2){
    if(c1.x==c2.x)
        return c1.y<c2.y;
    return c1.x<c2.x;
}

int main(){
    T=0;
    while(cin>>n>>d){
        T++;
        if(n==0) break;
        bool flag=false;
        for(int i=0;i<n;i++){
            cin>>c[i].x>>c[i].y;
            if(c[i].y>d) flag=true;
        }
        if(flag){
            cout<<"Case "<<T<<": -1"<<endl;
            continue;
        }
        sort(c, c+n, cmp);
        int ans=0;
        for(int i=0;i<n;){
            double l, r, xx;
            xx=sqrt(d*d-c[i].y*c[i].y);
            l=c[i].x*1.0-xx;
            r=c[i].x*1.0+xx;
            for(int j=i+1;j<n;j++){
                double l1, r1;
                xx=sqrt(d*d-c[j].y*c[j].y);
                l1=c[j].x*1.0-xx;
                r1=c[j].x*1.0+xx;
                if(l1>r) break;
                l=max(l, l1);
                r=min(r, r1);
                i=j;
            }
            i++;
            ans++;
        }
        cout<<"Case "<<T<<": "<<ans<<endl;
    }
}
```

[Stall Reservations](http://poj.org/problem?id=3190)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;

const int maxn=50000+5;
int n, pos[maxn];
struct node{
    int l, r, id;
    bool operator < (const node& b) const{
        return r>b.r;
    }
};
node c[maxn];
priority_queue<node> q;

bool cmp(node c1, node c2){
    if(c1.l==c2.l)
        return c1.r<c2.r;
    return c1.l<c2.l;
}

int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        scanf("%d%d", &c[i].l, &c[i].r);
        c[i].id=i;
    }
    sort(c, c+n, cmp);
    int ans=1;
    q.push(c[0]);
    pos[c[0].id]=1;
    for(int i=1;i<n;i++){
        node a=q.top();
        if(c[i].l>a.r){	// 能放在和a相同的stall
            pos[c[i].id]=pos[a.id];
            q.pop();
        }else{ // 新开一个stall
            ans++;
            pos[c[i].id]=ans;
        }
        q.push(c[i]);
    }
    cout<<ans<<endl;
    for(int i=0;i<n;i++)
        cout<<pos[i]<<endl;
}
```

[Yogurt factory](http://poj.org/problem?id=2393)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;

const int maxn=10000+5;
int n, s, c[maxn], y[maxn];
long long ans=0;

int main(){
    cin>>n>>s;
    for(int i=0;i<n;i++)
        cin>>c[i]>>y[i];
    for(int i=0,j;i<n;i++){
        ans+=c[i]*y[i];
        for(j=i+1;j<n;j++){
            // 如果储存的费用比生产费用的差价小，就生产未来几周的
            if(c[j]>c[i] && c[j]-c[i]>s*(j-i))
                ans+=y[j]*s*(j-i)+c[i]*y[j];
            else break;
        }
        i=j-1;
    }
    cout<<ans<<endl;
}
```

***[Packets](http://poj.org/problem?id=1017)***

> 从面积大的开始取，一块6\*6的板子可以去一块5\*5的板子剩下11个 1\*1的板子。取一块4\*4的板子剩下5个2\*2的板子。 6\*6的板子可以取四块3\*3的板子，在一块6\*6板子上取3\*3的板子数目为  1  2  3  4  的时候剩下 2\*2的板子分别为  5  3  1  0，剩余部分还可以去1\*1的板子。 若2\*2的板子有剩余，还可以分割成1\*1的板子。
>

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;

int a[10], ans, dir[]={0,5,3,1};

int main(){
    while(1){
        bool flag=0;
        for(int i=1;i<=6;i++){
            cin>>a[i];
            if(a[i]>0) flag=1;
        }
        if(!flag) break;

        ans=a[6]+a[5]+a[4]+(a[3]+3)/4;
        int a2=a[4]*5+dir[a[3]%4];
        if(a[2]>a2)
            ans+=ceil(1.0*(a[2]-a2)/9); // ans+=(a[2]-a2+8)/9;
        int a1=ans*36-a[6]*36-a[5]*25-a[4]*16-a[3]*9-a[2]*4;
        if(a[1]>a1)
            ans+=ceil(1.0*(a[1]-a1)/36); // ans+=(a[1]-a1+35)/36;
        cout<<ans<<endl;
    }
}
```

[Stripies](http://poj.org/problem?id=1862)
$$
r=2\sqrt{(2\sqrt{ab})c} \\
r^2=4(2\sqrt{ab}\cdot c) \\
r^4=64abc^2
$$
$c$ 越小 $r$ 越小

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;

const int maxn=100+5;
int n, a[maxn];

int main(){
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>a[i];
    sort(a, a+n);
    double ans=a[n-1];
    for(int i=n-2;i>=0;i--)
        ans=2*sqrt(a[i]*ans);
    printf("%.3f\n", ans);
}

```

[Protecting the Flowers](http://poj.org/problem?id=3262)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;

const int maxn=100000+5;
int n, sum=0;
struct node{int t, d; double r;};
node a[maxn];

bool cmp(node a, node b){
    return a.r>b.r;
}

int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i].t>>a[i].d;
        a[i].r=1.0*a[i].d/a[i].t;
        sum+=a[i].d;
    }
    sort(a, a+n, cmp);
    long long ans=0;
    for(int i=0;i<n;i++){
        sum-=a[i].d;
        ans+=sum*a[i].t*2;
    }
    cout<<ans<<endl;
}

```



[代理服务器](https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&tqId=21335&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
    string a[1005], b[5005];
    int n, m;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    cin>>m;
    for(int i=0;i<m;i++) cin>>b[i];
    
    int cnt=-1;
    // 每次选能用次数最多的
    for(int i=0;i<m;){
        int max=0, id=-1;
        for(int j=0;j<n;j++){
            int k;
            for(k=i;k<m;k++)
                if(a[j]==b[k]) break;
            if(k>max) {max=k; id=j;}
        }
        if(id==-1){cnt=-1; break;}
        i=max;
        cnt++;
    }
    cout<<cnt<<endl;
}
```

[最大序列和](https://www.nowcoder.com/practice/df219d60a7af4171a981ef56bd597f7b?tpId=40&tqId=21353&tPage=2&rp=2&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<iostream>
#include<algorithm>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        long long a, sum=0, ans=(1<<63);
        for(int i=0;i<n;i++){
            scanf("%lld", &a);
            sum=max(sum+a, a);
            ans=max(ans, sum);
        }
        cout<<ans<<endl;
    }
}
```



### 数学

#### 模运算

- $(a+b) \bmod p=(a \bmod p + b \bmod p) \bmod p$
- $(a-b) \bmod p=(a \bmod p - b \bmod p) \bmod p$
- $(a \times b) \bmod p=(a \bmod p \times b \bmod p) \bmod p$
- $(a \div b) \bmod p=(a \bmod p \div b^{-1} \bmod p) \bmod p$
- $a^b \bmod p = (a \bmod p)^b \bmod p$
- 结合律：$((a+b) \bmod p +c) \bmod p = (a+(b+c)\bmod p) \bmod p$
- 分配律：$((a+b)\bmod p \times c)\bmod p=((a\times c)\bmod p + (b\times c) \bmod p)\bmod p$

#### gcd && lcm

```c++
int gcd(int a, int b) {
    int r;
    while(b>0) {r=a%b; a=b; b=r;}
    return a;
}

int gcd_recursive(int a, int b){
    return b>0 ? gcd(b, a%b) : a;
}

int lcm(int a, int b){
    return a/gcd(a,b)*b;
}

```

#### exgcd

```c++
int extgcd(int a, int b, int& x, int& y)
{
    int d = a;
    if(b != 0){
        d = extgcd(b, a % b, y, x);
        y -= (a / b) * x;
    } else {
        x = 1;
        y = 0;
    }
    return d;
}

// 乘法逆元
int mod_inverse(int a, int m)
{
    int x, y;
    extgcd(a, m, x, y);
    return (m + x % m) % m;
}
```

#### 组合数

```c++
int c(int n, int k){
	int res = 1;
	for(int i=0;i<k;i++)
        res=res*(n-i)/(i+1);
	return res;
}
```

#### 快速幂

```c++
typedef long long ll;

ll mod_pow(ll x, ll n, ll mod){
    ll res=1;
    while(n>0){
        if(n&1) res=res*x%mod;
        x=x*x%mod;
        n>>=1;
    }
    return res;
}
```

[求root(N, k)](https://www.nowcoder.com/practice/9324a1458c564c4b9c4bfc3867a2aa66?tpId=40&tqId=21347&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

思路：[https://blog.csdn.net/lhyer/article/details/47905805](https://blog.csdn.net/lhyer/article/details/47905805)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<queue>
using namespace std;

typedef long long ll;
ll x, y, k;

ll mod_pow(ll x, ll n, ll mod){
    ll res=1;
    while(n>0){
        if(n&1) res=res*x%mod;
        x=x*x%mod;
        n>>=1;
    }
    return res;
}

int main(){
    while(cin>>x>>y>>k){
        ll ans=mod_pow(x, y, k-1);
        if(ans) cout<<ans<<endl;
        else cout<<k-1<<endl;
    }
}
```



#### 大数进制转换

```c++
// m进制转换为n进制
string convert(string a, int m, int n){
    string b;
    int l=a.size(), k=0;
    for(int i=0;i<l;){
        k=0;
        for(int j=i;j<l;j++){
            int t=(k*m+a[j]-'0')%n;
            a[j]=(k*m+a[j]-'0')/n+'0';
            k=t;
        }
        b+=char(k+'0');
        while(a[i]=='0') i++;
    }
    reverse(b.begin(), b.end());
    return b;
}
```

#### Miller Rabbin

```c++
LL modular_multi(LL x, LL y, LL mo){  
    LL t;  
    x%=mo;  
    for(t=0;y;x=(x<<1)%mo,y>>=1)  
        if (y&1)  
            t=(t+x)%mo;  
    return t;  
}  

LL modular_exp(LL num,LL t,LL mo){  
    LL ret=1,temp=num%mo;  
    for(;t;t>>=1,temp=modular_multi(temp,temp,mo))  
        if (t&1)  
            ret=modular_multi(ret,temp,mo);  
    return ret;
}  

bool miller_rabbin(LL n){  
    if (n==2)return true;  
    if (n<2||!(n&1))return false;  
    int t=0;  
    LL a,x,y,u=n-1;  
    while((u&1)==0) t++,u>>=1;
    for(int i=0;i<S;i++){  
        a=rand()%(n-1)+1;  
        x=modular_exp(a,u,n);  
        for(int j=0;j<t;j++){  
            y=modular_multi(x,x,n);  
            if (y==1&&x!=1&&x!=n-1)  
                return false;  
        ///其中用到定理，如果对模n存在1的非平凡平方根，则n是合数。  
        ///如果一个数x满足方程x^2≡1 (mod n),但x不等于对模n来说1的两个‘平凡’平方根：1或-1，则x是对模n来说1的非平凡平方根  
            x=y;  
        }
        if (x!=1)///根据费马小定理,若n是素数，有a^(n-1)≡1(mod n).因此n不可能是素数  
        return false;
    }
    return true;
}

```

#### 水题

[质因数的个数](https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=40&tqId=21338&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        int ans=0, i=2;
        double s=sqrt(n);
        while(n>1){
            // 不用筛质数！
            if(n%i==0){
                n/=i;
                ans++;
            }else i++;
            if(i>s) break; 
        }
        if(n>1) ans++;
        cout<<ans<<endl;
    }
}
```

[大整数的因子](https://www.nowcoder.com/practice/3d6cee12fbf54ea99bb165cbaba5823d?tpId=40&tqId=21370&tPage=2&rp=2&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
using namespace std;

string s;

int main(){
    while(cin>>s){
        int a=0;
        bool flag=false;
        for(int k=2;k<10;k++){
            a=0;
            for(int i=0;i<s.size();i++)
                a=(a*10+s[i]-'0')%k;
            a%=k;
            if(a==0) {
                if(flag) cout<<' ';
                cout<<k;
                flag=true;
            }
        }
        if(!flag) cout<<"none";
        cout<<endl;
    }
}
```

[排列与二进制](https://www.nowcoder.com/practice/647fc23dc4e147328cc484e3aeb6cc2a?tpId=40&tqId=21507&tPage=9&rp=9&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<queue>
using namespace std;

int main(){
    int m, n, ans;
    while(cin>>n>>m){
        if(n==0) break;
        ans=0;
        for(int i=n-m+1;i<=n;i++){
            int k=i;
            while(k%2==0){
                ans++;
                k/=2;
            }
        }
        cout<<ans<<endl;
    }
}
```



## 数据结构

### 二叉树

[二叉树遍历](https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=40&tqId=21342&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

string p;
int i=0;

struct node{
    char v;
    node* l;
    node* r;
};

node* build(){
    char c=p[i++];
    if(c=='#') return NULL;
    node* r=new node;
    r->v=c;
    r->l=build();
    r->r=build();
    return r;
}

void x(node* r){
    if(r==NULL) return;
    x(r->l);
    cout<<r->v<<' ';
    x(r->r);
}

void del(node* r){
    if(r==NULL) return;
    del(r->l);
    del(r->r);
    delete r;
}

int main(){
    while(cin>>p){
        i=0;
        node* r = build();
        x(r);
        cout<<endl;
        del(r);
    }
}
```

### 堆（优先队列）

- 普通用法

```c++
priority_queue<int, vector<int>, greater<int> > q;

int main(){
    q.push(3);
    q.push(1);
    q.push(2);
    while(!q.empty()){
        cout<<q.top()<<endl;
        q.pop();
    }
}
// 输出为
// 1
// 2
// 3
```

- 结构体

```c++
struct node{
    int x, y;
    bool operator < (node b) const{	// 注意const
        return y>b.y;	// 与结果相反
    }
};
priority_queue<node> q;

int main(){
    node a;
    a.y=1;
    q.push(a);
    a.y=3;
    q.push(a);
    a.y=2;
    q.push(a);
    while(!q.empty()){
        cout<<q.top().y<<endl;
        q.pop();
    }
}
// 输出为
// 1
// 2
// 3
```

- pair

```c++
typedef pair<int, int> P;
priority_queue<P, vector<P>, greater<P> > q; // 按p.first排序
```

